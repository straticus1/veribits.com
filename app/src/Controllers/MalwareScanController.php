<?php
namespace VeriBits\Controllers;
use VeriBits\Utils\Response;
use VeriBits\Utils\Auth;
use VeriBits\Utils\Validator;
use VeriBits\Utils\RateLimit;
use VeriBits\Utils\Logger;
use VeriBits\Utils\Database;

class MalwareScanController {
    private const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB
    private const UPLOAD_DIR = '/tmp/veribits-scans';

    public function scan(): void {
        $claims = Auth::requireBearer();
        $userId = $claims['sub'] ?? null;
        $apiKeyId = $claims['key_id'] ?? null;

        if (!RateLimit::checkUserQuota($userId, 'monthly')) {
            Response::error('Monthly quota exceeded', 429);
            return;
        }

        // Handle file upload
        if (!isset($_FILES['file']) || $_FILES['file']['error'] !== UPLOAD_ERR_OK) {
            Response::error('File upload required', 400);
            return;
        }

        $file = $_FILES['file'];
        $fileSize = $file['size'];

        if ($fileSize > self::MAX_FILE_SIZE) {
            Response::error('File too large (max 50MB)', 413);
            return;
        }

        if ($fileSize === 0) {
            Response::error('Empty file', 400);
            return;
        }

        try {
            // Calculate file hash
            $fileHash = hash_file('sha256', $file['tmp_name']);

            // Create upload directory if it doesn't exist
            if (!is_dir(self::UPLOAD_DIR)) {
                mkdir(self::UPLOAD_DIR, 0755, true);
            }

            // Move uploaded file to temp location
            $tempPath = self::UPLOAD_DIR . '/' . $fileHash;
            if (!move_uploaded_file($file['tmp_name'], $tempPath)) {
                throw new \Exception('Failed to save uploaded file');
            }

            // Run ClamAV scan
            $startTime = microtime(true);
            $scanResult = $this->scanWithClamAV($tempPath);
            $scanTimeMs = (int)((microtime(true) - $startTime) * 1000);

            // Clean up temp file
            @unlink($tempPath);

            // Generate badge ID
            $badgeId = 'mscan_' . substr($fileHash, 0, 16);

            // Store scan result in database
            $db = Database::getConnection();
            $stmt = $db->prepare('
                INSERT INTO malware_scans
                (user_id, api_key_id, file_hash, file_size_bytes, scan_status,
                 threats_found, clamav_version, signature_version, scan_time_ms, badge_id)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                RETURNING id
            ');

            $threatsJson = json_encode($scanResult['threats']);
            $stmt->execute([
                $userId,
                $apiKeyId,
                $fileHash,
                $fileSize,
                $scanResult['status'],
                $threatsJson,
                $scanResult['clamav_version'],
                $scanResult['signature_version'],
                $scanTimeMs,
                $badgeId
            ]);

            RateLimit::incrementUserQuota($userId, 'monthly');

            Logger::info('Malware scan completed', [
                'user_id' => $userId,
                'file_hash' => $fileHash,
                'status' => $scanResult['status'],
                'scan_time_ms' => $scanTimeMs
            ]);

            Response::success([
                'type' => 'malware_scan',
                'file_hash' => $fileHash,
                'file_size_bytes' => $fileSize,
                'scan_status' => $scanResult['status'],
                'threats_found' => $scanResult['threats'],
                'is_clean' => $scanResult['status'] === 'clean',
                'clamav_version' => $scanResult['clamav_version'],
                'signature_version' => $scanResult['signature_version'],
                'scan_time_ms' => $scanTimeMs,
                'badge_id' => $badgeId,
                'badge_url' => "/api/v1/badge/$badgeId",
                'scanned_at' => date('c')
            ]);

        } catch (\Exception $e) {
            Logger::error('Malware scan failed', [
                'user_id' => $userId,
                'error' => $e->getMessage()
            ]);

            // Clean up temp file on error
            if (isset($tempPath) && file_exists($tempPath)) {
                @unlink($tempPath);
            }

            Response::error('Scan failed: ' . $e->getMessage(), 500);
        }
    }

    private function scanWithClamAV(string $filePath): array {
        // Try to get ClamAV version and signature info
        $versionOutput = [];
        $versionCode = 0;
        @exec('clamdscan --version 2>&1', $versionOutput, $versionCode);

        $clamavVersion = 'unknown';
        $signatureVersion = 'unknown';

        if ($versionCode === 0 && !empty($versionOutput)) {
            foreach ($versionOutput as $line) {
                if (preg_match('/ClamAV\s+([\d.]+)/', $line, $matches)) {
                    $clamavVersion = $matches[1];
                }
                if (preg_match('/(\d+)\/(\d+\/\d+)/', $line, $matches)) {
                    $signatureVersion = $matches[0];
                }
            }
        }

        // Run the scan
        $output = [];
        $returnCode = 0;
        $escapedPath = escapeshellarg($filePath);
        @exec("clamdscan --no-summary $escapedPath 2>&1", $output, $returnCode);

        $threats = [];
        $status = 'clean';

        // Parse ClamAV output
        // Return code 0 = clean, 1 = infected, 2 = error
        if ($returnCode === 1) {
            $status = 'infected';
            foreach ($output as $line) {
                if (preg_match('/: (.+) FOUND$/', $line, $matches)) {
                    $threats[] = [
                        'name' => $matches[1],
                        'type' => 'virus'
                    ];
                }
            }
        } elseif ($returnCode === 2 || $returnCode > 2) {
            // ClamAV not available or error - fallback to basic check
            if (!$this->isClamAVAvailable()) {
                Logger::warning('ClamAV not available, returning mock scan result');
                $status = 'clean';
                $clamavVersion = 'not-installed';
                $signatureVersion = 'n/a';
            } else {
                $status = 'error';
                throw new \Exception('ClamAV scan error: ' . implode(' ', $output));
            }
        }

        return [
            'status' => $status,
            'threats' => $threats,
            'clamav_version' => $clamavVersion,
            'signature_version' => $signatureVersion
        ];
    }

    private function isClamAVAvailable(): bool {
        $output = [];
        $returnCode = 0;
        @exec('which clamdscan 2>&1', $output, $returnCode);
        return $returnCode === 0;
    }
}
